<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CKHQ – Flick Free Throw (Vanilla)</title>
<style>
  :root{--bg:#07090f;--card:#0b0f18;--fg:#fff;--teal:#00ffc6;--border:rgba(255,255,255,.08)}
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui;display:flex;justify-content:center}
  .wrap{width:100%;max-width:1000px;padding:24px}
  .hdr{display:flex;justify-content:space-between;align-items:center}
  .arena{margin-top:12px;background:var(--card);border:1px solid var(--border);border-radius:14px;padding:10px}
  .canvas{width:100%;aspect-ratio:900/520;border-radius:12px;overflow:hidden;border:1px solid var(--border);background:#0b0f18}
  canvas{width:100%;height:100%;display:block}
  .stats{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-top:12px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
  .lbl{font-size:11px;letter-spacing:.14em;text-transform:uppercase;color:#cdd6f6a0}
  .val{font-size:26px;font-weight:800;margin-top:4px}
  .hint{opacity:.7;font-size:14px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hdr"><h1>CKHQ <span style="color:var(--teal)">Flick</span> Free Throw</h1><div class="hint">Drag the ball → release • R = Reset</div></div>
    <div class="stats">
      <div class="card"><div class="lbl">Attempts</div><div class="val" id="att">0</div></div>
      <div class="card"><div class="lbl">Makes</div><div class="val" id="mk">0</div></div>
      <div class="card"><div class="lbl">FG%</div><div class="val" id="fg">0%</div></div>
      <div class="card"><div class="lbl">Streak</div><div class="val" id="st">0</div></div>
    </div>
    <div class="arena"><div class="canvas"><canvas id="c" width="900" height="520"></canvas></div></div>
  </div>

<script>
(() => {
  const cv = document.getElementById('c'), ctx = cv.getContext('2d');
  const W=900,H=520,floorY=H-60;

  // Hoop (side view)
  const rimX=W-180, rimY=floorY-240;
  const rimInner=18, rimOuter=24;
  const boardX=rimX+55, boardTop=rimY-60, boardBot=rimY+60;

  // Scoring: center crosses this line within lane = make
  let scoreLineY = rimY + 6;      // a bit below rim height
  let laneHalf   = 30;            // widen/narrow to tune difficulty

  // Ball
  const spawnX=220, spawnY=floorY-120, R=11;
  let b = {x:spawnX,y:spawnY,vx:0,vy:0,px:spawnX,py:spawnY,flying:false,scored:false};
  const g=900, air=0.998, cor=0.5, dt=1/60;

  // Stats
  let att=0,mk=0,st=0; const $=(id)=>document.getElementById(id);
  const upd=()=>{ $('att').textContent=att; $('mk').textContent=mk; $('fg').textContent=(att?Math.round(mk/att*100):0)+'%'; $('st').textContent=st; }; upd();

  // Drag-to-shoot
  let dragging=false, dragStart=null;
  function toWorld(e){const r=cv.getBoundingClientRect();const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;return {x:x*(W/r.width),y:y*(H/r.height)};}

  function onDown(e){
    const p=toWorld(e);
    const d=Math.hypot(p.x-b.x,p.y-b.y);
    if(d<=R+14 && !b.flying){ dragging=true; dragStart=p; }
  }
  function onMove(e){
    if(!dragging) return;
    const p=toWorld(e);
    // draw a ghost while dragging (we don’t move ball yet)
    ghost=p;
  }
  function onUp(e){
    if(!dragging) return;
    const p=toWorld(e);
    dragging=false;
    // velocity = drag vector * scale (drag from ball to mouse)
    const dx = p.x - b.x, dy = p.y - b.y;
    const scale = 3.2;                 // tweak for feel (higher = faster)
    b.vx = dx * scale;
    b.vy = dy * scale;
    // invert Y because up should be negative vy
    b.vy *= -1;
    b.flying=true; b.scored=false; att++; upd();
    ghost=null;
  }
  let ghost=null;

  cv.addEventListener('mousedown', onDown);
  cv.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
  cv.addEventListener('touchstart', e=>{e.preventDefault(); onDown(e)}, {passive:false});
  cv.addEventListener('touchmove',  e=>{e.preventDefault(); onMove(e)},  {passive:false});
  cv.addEventListener('touchend',   e=>{onUp(e)});

  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='r'){ reset(false); }
  });

  function reset(hard){
    b={x:spawnX,y:spawnY,vx:0,vy:0,px:spawnX,py:spawnY,flying:false,scored:false};
    if(hard){att=mk=st=0;} upd();
  }

  // collisions
  function collideCircle(cx,cy,r){
    const dx=b.x-cx, dy=b.y-cy, dist=Math.hypot(dx,dy), min=r+R;
    if(dist<min){
      const nx=dx/(dist||1), ny=dy/(dist||1), overlap=min-dist;
      b.x+=nx*overlap; b.y+=ny*overlap;
      const dot=b.vx*nx+b.vy*ny;
      b.vx-=(1+cor)*dot*nx; b.vy-=(1+cor)*dot*ny;
      b.vx*=0.985; b.vy*=0.985;
    }
  }

  // flash on score
  let flash=0;

  function step(){
    // physics
    if(b.flying){
      b.px=b.x; b.py=b.y;

      b.vy+=g*dt;
      b.x+=b.vx*dt;
      b.y+=b.vy*dt;
      b.vx*=air; b.vy*=air;

      // ===== scoring (center-line crossing) BEFORE collisions =====
      const crossed = (b.py <= scoreLineY && b.y >= scoreLineY);
      if(!b.scored && crossed){
        const t = (scoreLineY - b.py) / (b.y - b.py || 1);
        const xCross = b.px + (b.x - b.px)*t;
        const inLane = xCross >= (rimX - laneHalf) && xCross <= (rimX + laneHalf);
        if(inLane){
          b.scored=true; mk++; st++; upd(); flash=10;
        }
      }

      // floor
      if(b.y+R>floorY){
        b.y=floorY-R; b.vy*=-cor; b.vx*=0.9;
        if(Math.abs(b.vx)<5 && Math.abs(b.vy)<5){ b.flying=false; b.vx=b.vy=0; if(!b.scored){st=0; upd();} }
      }
      // backboard
      if(b.x+R>boardX && b.y>boardTop && b.y<boardBot){ b.x=boardX-R; b.vx*=-cor; }
      // rim rings
      collideCircle(rimX-rimOuter,rimY,rimOuter);
      collideCircle(rimX+rimOuter,rimY,rimOuter);

      // out-of-bounds → reset ball
      if(b.x < -50 || b.x > W+50 || b.y < -100 || b.y > H+100){
        b.flying=false; if(!b.scored){st=0; upd();} reset(false);
      }
    }

    draw();
    requestAnimationFrame(step);
  }

  function line(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); }

  function draw(){
    ctx.clearRect(0,0,W,H);
    const grad=ctx.createLinearGradient(0,0,0,H); grad.addColorStop(0,"#0d0f15"); grad.addColorStop(1,"#050608"); ctx.fillStyle=grad; ctx.fillRect(0,0,W,H);

    // court box + floor
    ctx.fillStyle="#1b2330"; rounded(20,20,W-40,H-40,24); ctx.fill();
    ctx.fillStyle="#0e1320"; rounded(20,floorY-40,W-40,80,18); ctx.fill();

    // free-throw circle/line
    ctx.strokeStyle="#28324a"; ctx.lineWidth=2; circle(spawnX+30,floorY-120,60); ctx.stroke(); line(spawnX-50,floorY-60,spawnX+100,floorY-60);

    // backboard
    ctx.fillStyle="#d9e3ff0f"; ctx.fillRect(boardX,boardTop,8,boardBot-boardTop);

    // rim visuals
    ctx.strokeStyle="#ff7d00"; ctx.lineWidth=4; arc(rimX,rimY,24,0,Math.PI); ctx.stroke();
    ctx.strokeStyle="#ffd19a"; ctx.lineWidth=2; arc(rimX,rimY,18,0,Math.PI); ctx.stroke();

    // optional scoring line (debug, faint)
    ctx.strokeStyle="rgba(255,255,255,.18)"; ctx.lineWidth=3; line(rimX-laneHalf,scoreLineY,rimX+laneHalf,scoreLineY);

    // swish flash
    if(flash>0){ flash--; ctx.save(); ctx.globalAlpha=Math.min(.5,flash/10); ctx.strokeStyle="#00ffc6"; ctx.lineWidth=6; arc(rimX,rimY+4,24,0.1*Math.PI,0.9*Math.PI); ctx.stroke(); ctx.restore(); }

    // ball
    ctx.fillStyle="#f77f07"; circle(b.x,b.y,R); ctx.fill();
    ctx.strokeStyle="#4a2808"; ctx.lineWidth=1.2; circle(b.x,b.y,R-2); ctx.stroke(); line(b.x-R,b.y,b.x+R,b.y); line(b.x,b.y-R,b.x,b.y+R);

    // ghost while dragging
    if(ghost){ ctx.strokeStyle="#00ffc6"; ctx.lineWidth=2; line(b.x,b.y,ghost.x,ghost.y); circle(ghost.x,ghost.y,6); ctx.stroke(); }
  }

  function arc(x,y,r,a0,a1,ccw=false){ ctx.beginPath(); ctx.arc(x,y,r,a0,a1,ccw); }
  function rounded(x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
